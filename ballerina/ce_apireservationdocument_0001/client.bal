// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.org).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;
import ballerinax/sap;

#

#

# This service contains the header and item nodes for reservation documents. You can create a reservation for a material with some quantity and assign that reserved material to a cost center, sales order, or asset. A reservation can also be created for a transfer posting from one plant to another. For an existing reservation, you can change the updatable fields of the items. The service also allows you to delete existing reservation documents. It can be consumed by external systems and user interfaces.
public isolated client class Client {
    final sap:Client clientEp;

    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string hostname, int port = 443) returns error? {
        string serviceUrl = string `https://${hostname}:${port}/sap/opu/odata4/sap/api_reservation_document/srvd_a2x/sap/apireservationdocument/0001`;
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        sap:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }

    # Add new entity to ReservationDocument
    #
    # + headers - Headers to be sent with the request 
    # + payload - New entity 
    # + return - Created entity 
    remote isolated function createReservationDocument(CreateA_ReservationDocumentHeader_2 payload, map<string|string[]> headers = {}) returns A_ReservationDocumentHeader_2|error {
        string resourcePath = string `/ReservationDocument`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add new entity to related _ReservationDocumentItem
    #
    # + Reservation - Number of reservation/dependent requirements
    # + headers - Headers to be sent with the request 
    # + payload - New entity 
    # + return - Created entity 
    remote isolated function createReservationDocumentItemOfReservationDocument(string Reservation, CreateA_ReservationDocumentItem_2 payload, map<string|string[]> headers = {}) returns A_ReservationDocumentItem_2|error {
        string resourcePath = string `/ReservationDocument/${getEncodedUri(Reservation)}/_ReservationDocumentItem`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete entity from ReservationDocument
    #
    # + Reservation - Number of reservation/dependent requirements
    # + headers - Headers to be sent with the request 
    # + return - Success 
    remote isolated function deleteReservationDocument(string Reservation, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/ReservationDocument/${getEncodedUri(Reservation)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get entity from ReservationDocument by key
    #
    # + Reservation - Number of reservation/dependent requirements
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getReservationDocument(string Reservation, map<string|string[]> headers = {}, *GetReservationDocumentQueries queries) returns A_ReservationDocumentHeader_2|error {
        string resourcePath = string `/ReservationDocument/${getEncodedUri(Reservation)}`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from ReservationDocumentItem by key
    #
    # + Reservation - Number of reservation/dependent requirements
    # + ReservationItem - Item Number of Reservation / Dependent Requirements
    # + RecordType - Record type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getReservationDocumentItem(string Reservation, string ReservationItem, string RecordType, map<string|string[]> headers = {}, *GetReservationDocumentItemQueries queries) returns A_ReservationDocumentItem_2|error {
        string resourcePath = string `/ReservationDocumentItem/${getEncodedUri(Reservation)}/${getEncodedUri(ReservationItem)}/${getEncodedUri(RecordType)}`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get related _ReservationDocument
    #
    # + Reservation - Number of reservation/dependent requirements
    # + ReservationItem - Item Number of Reservation / Dependent Requirements
    # + RecordType - Record type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getReservationDocumentOfReservationDocumentItem(string Reservation, string ReservationItem, string RecordType, map<string|string[]> headers = {}, *GetReservationDocumentOfReservationDocumentItemQueries queries) returns A_ReservationDocumentHeader_2|error {
        string resourcePath = string `/ReservationDocumentItem/${getEncodedUri(Reservation)}/${getEncodedUri(ReservationItem)}/${getEncodedUri(RecordType)}/_ReservationDocument`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from ReservationDocumentItem
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listReservationDocumentItems(map<string|string[]> headers = {}, *ListReservationDocumentItemsQueries queries) returns CollectionOfA_ReservationDocumentItem_2|error {
        string resourcePath = string `/ReservationDocumentItem`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from related _ReservationDocumentItem
    #
    # + Reservation - Number of reservation/dependent requirements
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listReservationDocumentItemsOfReservationDocument(string Reservation, map<string|string[]> headers = {}, *ListReservationDocumentItemsOfReservationDocumentQueries queries) returns CollectionOfA_ReservationDocumentItem_2|error {
        string resourcePath = string `/ReservationDocument/${getEncodedUri(Reservation)}/_ReservationDocumentItem`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from ReservationDocument
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listReservationDocuments(map<string|string[]> headers = {}, *ListReservationDocumentsQueries queries) returns CollectionOfA_ReservationDocumentHeader_2|error {
        string resourcePath = string `/ReservationDocument`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update entity in ReservationDocument
    #
    # + Reservation - Number of reservation/dependent requirements
    # + headers - Headers to be sent with the request 
    # + payload - New property values 
    # + return - Success 
    remote isolated function patchReservationDocument(string Reservation, UpdateA_ReservationDocumentHeader_2 payload, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/ReservationDocument/${getEncodedUri(Reservation)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Update entity in ReservationDocumentItem
    #
    # + Reservation - Number of reservation/dependent requirements
    # + ReservationItem - Item Number of Reservation / Dependent Requirements
    # + RecordType - Record type
    # + headers - Headers to be sent with the request 
    # + payload - New property values 
    # + return - Success 
    remote isolated function patchReservationDocumentItem(string Reservation, string ReservationItem, string RecordType, UpdateA_ReservationDocumentItem_2 payload, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/ReservationDocumentItem/${getEncodedUri(Reservation)}/${getEncodedUri(ReservationItem)}/${getEncodedUri(RecordType)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Send a group of requests
    #
    # + headers - Headers to be sent with the request 
    # + request - Batch request 
    # + return - Batch response 
    remote isolated function performBatchOperation(http:Request request, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/$batch`;
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }
}
