// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.org).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;
import ballerinax/sap;

#

#

# For example, a user might create a reservation for a material with some quantity and assign that reserved material to a cost center, a sales order or an asset. A reservation can also be created for a transfer posting from one plant to another. For an existing reservation, you can change the updatable fields of the items. The service also allows to delete existing reservation documents. It can be consumed by external systems and user interfaces.
public isolated client class Client {
    final sap:Client clientEp;

    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string hostname, int port = 443) returns error? {
        string serviceUrl = string `https://${hostname}:${port}/sap/opu/odata/sap/API_RESERVATION_DOCUMENT_SRV`;
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        sap:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }

    # Creates a reservation document
    #
    # + headers - Headers to be sent with the request 
    # + payload - New entity 
    # + return - Created entity 
    remote isolated function createA_ReservationDocumentHeader(CreateA_ReservationDocumentHeader payload, map<string|string[]> headers = {}) returns A_ReservationDocumentHeader_1|error {
        string resourcePath = string `/A_ReservationDocumentHeader`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Deletes a reservation document
    #
    # + Reservation - Number of reservation/dependent requirements
    # + headers - Headers to be sent with the request 
    # + return - Success 
    remote isolated function deleteA_ReservationDocumentHeader(string Reservation, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/A_ReservationDocumentHeader('${getEncodedUri(Reservation)}')`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Reads information for a specific reservation document header
    #
    # + Reservation - Number of reservation/dependent requirements
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getA_ReservationDocumentHeader(string Reservation, map<string|string[]> headers = {}, *GetA_ReservationDocumentHeaderQueries queries) returns A_ReservationDocumentHeaderWrapper|error {
        string resourcePath = string `/A_ReservationDocumentHeader('${getEncodedUri(Reservation)}')`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Reads information on reservation document items level for a specific reservation document
    #
    # + Reservation - Number of reservation/dependent requirements
    # + ReservationItem - Item Number of Reservation / Dependent Requirements
    # + RecordType - Record type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getA_ReservationDocumentItem(string Reservation, string ReservationItem, string RecordType, map<string|string[]> headers = {}, *GetA_ReservationDocumentItemQueries queries) returns A_ReservationDocumentItemWrapper|error {
        string resourcePath = string `/A_ReservationDocumentItem(Reservation='${getEncodedUri(Reservation)}',ReservationItem='${getEncodedUri(ReservationItem)}',RecordType='${getEncodedUri(RecordType)}')`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Reads information on reservation document header level
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listA_ReservationDocumentHeaders(map<string|string[]> headers = {}, *ListA_ReservationDocumentHeadersQueries queries) returns CollectionOfA_ReservationDocumentHeaderWrapper|error {
        string resourcePath = string `/A_ReservationDocumentHeader`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Reads information on reservation document items level
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listA_ReservationDocumentItems(map<string|string[]> headers = {}, *ListA_ReservationDocumentItemsQueries queries) returns CollectionOfA_ReservationDocumentItemWrapper|error {
        string resourcePath = string `/A_ReservationDocumentItem`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Reads information for a specific reservation document and reservation document items
    #
    # + Reservation - Number of reservation/dependent requirements
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listReservationDocumentItemsOfA_ReservationDocumentHeader(string Reservation, map<string|string[]> headers = {}, *ListReservationDocumentItemsOfA_ReservationDocumentHeaderQueries queries) returns CollectionOfA_ReservationDocumentItemWrapper|error {
        string resourcePath = string `/A_ReservationDocumentHeader('${getEncodedUri(Reservation)}')/to_ReservationDocumentItem`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Send a group of requests
    #
    # + headers - Headers to be sent with the request 
    # + request - Batch request 
    # + return - Batch response 
    remote isolated function performBatchOperation(http:Request request, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/$batch`;
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }
}
